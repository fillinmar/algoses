        -:    0:Source:/home/fillinmar/algoses/2модуль/4.1/main.cpp
        -:    0:Graph:/home/fillinmar/algoses/2модуль/4.1/cmake-build-debug-coverage/CMakeFiles/4_1.dir/main.cpp.gcno
        -:    0:Data:/home/fillinmar/algoses/2модуль/4.1/cmake-build-debug-coverage/CMakeFiles/4_1.dir/main.cpp.gcda
        -:    0:Runs:1
        -:    1:#include <iostream>
        -:    2:#include <vector>
        -:    3:
        -:    4:using namespace std;
        -:    5:
        -:    6:template<class T>
        -:    7:class SoldierCompare {
        -:    8:public:
function _ZN14SoldierCompareIiEclERKiS2_ called 15 returned 100% blocks executed 100%
       15:    9:    bool operator()(const T &l, const T &r)  {
       15:   10:        return l > r;
       15:   10-block  0
        -:   11:    }
        -:   12:};
        -:   13:
        -:   14:template<class T, class Comparator = less<T>>
        -:   15:class AVLTree {
        -:   16:    struct Node {
function _ZN7AVLTreeIi14SoldierCompareIiEE4NodeC2ERKi called 4 returned 100% blocks executed 100%
        4:   17:        Node(const T &key)
        4:   18:                : key(key), left(nullptr), right(nullptr), height(1), weight(1)
        -:   19:        {
        4:   20:        }
        -:   21:        T key;
        -:   22:        Node *left;
        -:   23:        Node *right;
        -:   24:        int height;
        -:   25:        int weight;            //Кол-во вершин, содержащихся в поддереве данной ноды
        -:   26://        explicit Node(const T &key);
        -:   27:    };
        -:   28:public:
function _ZN7AVLTreeIi14SoldierCompareIiEE6SearchERKi called 1 returned 100% blocks executed 100%
        1:   29:    bool Search(const T &key){
        1:   30:        return Find(key).first;
        1:   30-block  0
call    0 returned 1
        -:   31:    }
        -:   32:
function _ZN7AVLTreeIi14SoldierCompareIiEEC2ERKS1_ called 1 returned 100% blocks executed 100%
        1:   33:    AVLTree(const Comparator &compare = Comparator()) : root(nullptr) {};
        -:   34:
function _ZN7AVLTreeIi14SoldierCompareIiEED2Ev called 1 returned 100% blocks executed 100%
        1:   35:    ~AVLTree() {
        1:   36:        destroyTree(root);
        1:   36-block  0
call    0 returned 1
        1:   37:    }
        -:   38:
function _ZN7AVLTreeIi14SoldierCompareIiEE3AddERKi called 4 returned 100% blocks executed 100%
        4:   39:    void Add(const T &key) {
        4:   40:        ++size;
        4:   41:        Node *current = root;
        4:   42:        Node *previous = nullptr;
        -:   43:
        4:   44:        if (root == nullptr) {
        4:   44-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:   45:            root = new Node(key);
        1:   45-block  0
call    0 returned 1
call    1 returned 1
        1:   46:            return;
        -:   47:        }
        -:   48:        while (true) {
        7:   49:            if (current == nullptr) {
        7:   49-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 4
        3:   50:                if (cmp(key, previous->key)) {
        3:   50-block  0
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1:   51:                    previous->left = new Node(key);
        1:   51-block  0
call    0 returned 1
call    1 returned 1
        -:   52:                } else {
        2:   53:                    previous->right = new Node(key);
        2:   53-block  0
call    0 returned 2
call    1 returned 2
        -:   54:                }
        3:   55:                return;
        3:   55-block  0
        4:   56:            } else if (cmp(key, current->key)) {
        4:   56-block  0
call    0 returned 4
branch  1 taken 2 (fallthrough)
branch  2 taken 2
        2:   57:                previous = current;
        2:   58:                current = current->left;
        2:   58-block  0
        -:   59:            } else {
        2:   60:                previous = current;
        2:   61:                current = current->right;
        2:   61-block  0
        -:   62:            }
        -:   63:        }
        -:   64:    }
        -:   65:
function _ZN7AVLTreeIi14SoldierCompareIiEE6DeleteERKi called 1 returned 100% blocks executed 67%
        1:   66:    bool Delete(const T &key) {
        1:   67:        if (Search(key)) {
        1:   67-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:   68:            root = deleteInternal(root, key);
    %%%%%:   68-block  0
call    0 never executed
    #####:   69:            --size;
    #####:   70:            return true;
        -:   71:        } else {
        1:   72:            return false;
        1:   72-block  0
        -:   73:        }
        -:   74:    };
        -:   75:
        -:   76:    // Метод возвращает индекс, который будет соответствовать
        -:   77:    // индексу элемента после его добавления
        -:   78:    int Position(const T &key);
        -:   79:
        -:   80:    //Возвращает К-ю порядковую статистику
        -:   81:    pair<bool, T> KStatistics(int index);
        -:   82:
        -:   83:private:
        -:   84:
function _ZN7AVLTreeIi14SoldierCompareIiEE11destroyTreeEPNS2_4NodeE called 9 returned 100% blocks executed 100%
        9:   85:    void destroyTree(Node *node)
        -:   86:    {
        9:   87:        if (node)
        9:   87-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 5
        -:   88:        {
        4:   89:            destroyTree(node->left);
        4:   89-block  0
call    0 returned 4
        4:   90:            destroyTree(node->right);
call    0 returned 4
        4:   91:            delete node;
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:   91-block  0
call    2 returned 4
        -:   92:        }
        9:   93:    }
        -:   94:    Node *root;
        -:   95:    int size;
        -:   96:    Comparator cmp;
        -:   97:
function _ZN7AVLTreeIi14SoldierCompareIiEE7FindMinEPNS2_4NodeE called 0 returned 0% blocks executed 0%
    #####:   98:    Node *FindMin(Node *root){
    #####:   99:        if (root == nullptr) {
    %%%%%:   99-block  0
branch  0 never executed
branch  1 never executed
    #####:  100:            return nullptr;
    %%%%%:  100-block  0
        -:  101:        }
    #####:  102:        while (root->left != nullptr) {
    %%%%%:  102-block  0
branch  0 never executed
branch  1 never executed
    #####:  103:            root = root->left;
    %%%%%:  103-block  0
        -:  104:        }
    #####:  105:        return root;
    %%%%%:  105-block  0
        -:  106:    }
function _ZN7AVLTreeIi14SoldierCompareIiEE4FindERKi called 1 returned 100% blocks executed 62%
        1:  107:    pair<bool,Node *> Find(const T &key) {
        1:  108:        Node *current = root;
        1:  108-block  0
        -:  109:
        -:  110:        while (true) {
        3:  111:            if (current == nullptr) {
        3:  111-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:  112:                return make_pair(false, nullptr);
        1:  112-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  112-block  1
call    3 returned 1
    $$$$$:  112-block  2
    $$$$$:  112-block  3
       2*:  113:            } else if (!(cmp(current->key, key)) && !(cmp(key, current->key))) {
        2:  113-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    %%%%%:  113-block  1
call    3 never executed
branch  4 never executed
branch  5 never executed
    %%%%%:  113-block  2
        2:  113-block  3
        2:  113-block  4
branch  6 taken 0 (fallthrough)
branch  7 taken 2
    #####:  114:                return make_pair(true, current);
    %%%%%:  114-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    %%%%%:  114-block  1
    %%%%%:  114-block  2
    $$$$$:  114-block  3
        2:  115:            } else if (cmp(key, current->key)) {
        2:  115-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
    #####:  116:                current = current->left;
    %%%%%:  116-block  0
        -:  117:            } else {
        2:  118:                current = current->right;
        2:  118-block  0
        -:  119:            }
        -:  120:        }
        -:  121:    }
        -:  122:
        -:  123:    //Функция для удаления минимума в дереве для Delete
function _ZN7AVLTreeIi14SoldierCompareIiEE9RemoveMinEPNS2_4NodeE called 0 returned 0% blocks executed 0%
    #####:  124:    Node *RemoveMin(Node *root) {
    #####:  125:        if (root->left == nullptr) {           //Как только нашли минимум, подвязываем
    %%%%%:  125-block  0
branch  0 never executed
branch  1 never executed
    #####:  126:            return root->right;                             //правого ребенка к родителю
    %%%%%:  126-block  0
        -:  127:        }
        -:  128:
    #####:  129:        root->left = RemoveMin(root->left);                   //Рекурсивно балансируем
    %%%%%:  129-block  0
call    0 never executed
        -:  130:
    #####:  131:        return Balance(root);
call    0 never executed
        -:  132:    }
        -:  133:
function _ZN7AVLTreeIi14SoldierCompareIiEE14deleteInternalEPNS2_4NodeERKi called 0 returned 0% blocks executed 0%
    #####:  134:    Node *deleteInternal(Node *node, const T &key) {
    #####:  135:        if (cmp(root->key, key)) {                      //Спуск по ключу
    %%%%%:  135-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  136:            root->right = deleteInternal(root->right, key);
    %%%%%:  136-block  0
call    0 never executed
    #####:  137:        } else if (cmp(key, root->key)) {
    %%%%%:  137-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  138:            root->left = deleteInternal(root->left, key);
    %%%%%:  138-block  0
call    0 never executed
        -:  139:        } else {
    #####:  140:            if (root->right == nullptr) { //Нет правого поддерева -> подвязываем левое поддерево
    %%%%%:  140-block  0
branch  0 never executed
branch  1 never executed
    #####:  141:                Node *tmp = root->left;
    #####:  142:                delete root;
    %%%%%:  142-block  0
branch  0 never executed
branch  1 never executed
    %%%%%:  142-block  1
call    2 never executed
    #####:  143:                return tmp;
    %%%%%:  143-block  0
        -:  144:            }
    #####:  145:            Node *min = FindMin(root->right); //Есть правое поддерево -> ищем минимум
    %%%%%:  145-block  0
call    0 never executed
    #####:  146:            root->right = RemoveMin(root->right);    //в правом поддереве, удаляем его и
call    0 never executed
    #####:  147:            Node *tmp_left = root->left; //рекурсивно балансируем его
    #####:  148:            Node *tmp_right = root->right; //Вставляем минимум вместо удаленной ноды
    #####:  149:            delete root;
branch  0 never executed
branch  1 never executed
    %%%%%:  149-block  0
call    2 never executed
    #####:  150:            root = min;
    #####:  151:            min->left = tmp_left;
    #####:  152:            min->right = tmp_right;
    %%%%%:  152-block  0
        -:  153:        }
        -:  154:
    #####:  155:        return Balance(root);                  //Возвращаем сбалансированное поддерево
    %%%%%:  155-block  0
call    0 never executed
        -:  156:    }
        -:  157:
function _ZN7AVLTreeIi14SoldierCompareIiEE6WeightEPNS2_4NodeE called 2 returned 100% blocks executed 100%
        2:  158:    int Weight(Node *node){
        2:  159:        if (node == nullptr) {
        2:  159-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  160:            return 0;
        1:  160-block  0
        -:  161:        }
        -:  162:
        1:  163:        return node->weight;
        1:  163-block  0
        -:  164:    }
        -:  165:
function _ZN7AVLTreeIi14SoldierCompareIiEE6HeightEPNS2_4NodeE called 0 returned 0% blocks executed 0%
    #####:  166:    int Height(Node *node){
    #####:  167:        if (node == nullptr) {
    %%%%%:  167-block  0
branch  0 never executed
branch  1 never executed
    #####:  168:            return 0;
    %%%%%:  168-block  0
        -:  169:        }
        -:  170:
    #####:  171:        return node->height;
    %%%%%:  171-block  0
        -:  172:    }
        -:  173:
function _ZN7AVLTreeIi14SoldierCompareIiEE13BalanceFactorEPNS2_4NodeE called 0 returned 0% blocks executed 0%
    #####:  174:    int BalanceFactor(Node *node){
    #####:  175:        return Height(node->left) - Height(node->right);
    %%%%%:  175-block  0
call    0 never executed
call    1 never executed
        -:  176:    }
        -:  177:
        -:  178:    //Вспомогательная функция для метода Position
function _ZN7AVLTreeIi14SoldierCompareIiEE13PositionTrailEPNS2_4NodeERKi called 8 returned 100% blocks executed 100%
        8:  179:    int PositionTrail(Node *node, const T &key){
        -:  180:        {
        8:  181:            if (node == nullptr) {                        //Дойдя до нуля, возвращает нуль
        8:  181-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 4
        4:  182:                return 0;
        4:  182-block  0
        -:  183:            }
        -:  184:
        4:  185:            if (cmp(key, node->key)) {// Если ключ меньше, то рекурсивно спускается влево
        4:  185-block  0
call    0 returned 4
branch  1 taken 2 (fallthrough)
branch  2 taken 2
        2:  186:                return PositionTrail(node->left, key);
        2:  186-block  0
call    0 returned 2
        -:  187:            }
        -:  188:
        2:  189:            return PositionTrail(node->right, key) + Weight(node->left) + 1; //Если больше, то спускается влево, добавляя
        2:  189-block  0
call    0 returned 2
call    1 returned 2
        -:  190:        }
        -:  191:    }
        -:  192:
        -:  193:    //Вспомогательная ф-я для метода Kstatistics
function _ZN7AVLTreeIi14SoldierCompareIiEE15StatisticsTrailEPNS2_4NodeEi called 0 returned 0% blocks executed 0%
    #####:  194:    T StatisticsTrail(Node *node, int index){
    #####:  195:        if (Weight(node->left) == index) { //Если вес левой ноды равен индексу, возвращаем ее ключ
    %%%%%:  195-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  196:            return node->key;
    %%%%%:  196-block  0
        -:  197:        }
        -:  198:
    #####:  199:        if (index < Weight(node->left)) { //Индекс меньше левой ноды -> рекурсивно идем в левое поддерево
    %%%%%:  199-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  200:            return StatisticsTrail(node->left, index);
    %%%%%:  200-block  0
call    0 never executed
        -:  201:        }
        -:  202:
    #####:  203:        return StatisticsTrail(node->right, index - (Weight(node->left) + 1));
    %%%%%:  203-block  0
call    0 never executed
call    1 never executed
        -:  204:        // Индекс больше веса левой ноды -> идем в правое поддерево с индексом
        -:  205:        // (необходимым весом), равным инд - вес л.п. + 1
        -:  206:    }
        -:  207:
        -:  208:    Node *AVLInsert(Node *root, const T &key){
        -:  209:
        -:  210:        if (root == nullptr) {                     //Дойдя до нуля, создаем новый лист
        -:  211:            root = Node(key);
        -:  212:        } else {
        -:  213:            if (cmp(key, root->key)) {                    //Спуск по ключу
        -:  214:                root->left = AVLInsert(root->left, key);
        -:  215:            } else {
        -:  216:                root->right = AVLInsert(root->right, key);
        -:  217:            }
        -:  218:        }
        -:  219:
        -:  220:        return Balance(root);    //Балансировка поддерева и возврат наверх по рекурсии
        -:  221:    }
        -:  222:
        -:  223:    Node *AVLErase(Node *root, const T &key){
        -:  224:        if (cmp(root->key, key)) {                      //Спуск по ключу
        -:  225:            root->right = AVLErase(root->right, key);
        -:  226:        } else if (cmp(key, root->key)) {
        -:  227:            root->left = AVLErase(root->left, key);
        -:  228:        } else {
        -:  229:            if (root->right == nullptr) { //Нет правого поддерева -> подвязываем левое поддерево
        -:  230:                Node *tmp = root->left;
        -:  231:                delete root;
        -:  232:                return tmp;
        -:  233:            }
        -:  234:            Node *min = FindMin(root->right); //Есть правое поддерево -> ищем минимум
        -:  235:            root->right = RemoveMin(root->right);    //в правом поддереве, удаляем его и
        -:  236:            Node *tmp_left = root->left; //рекурсивно балансируем его
        -:  237:            Node *tmp_right = root->right; //Вставляем минимум вместо удаленной ноды
        -:  238:            delete root;
        -:  239:            root = min;
        -:  240:            min->left = tmp_left;
        -:  241:            min->right = tmp_right;
        -:  242:        }
        -:  243:
        -:  244:        return Balance(root);                  //Возвращаем сбалансированное поддерево
        -:  245:    }
        -:  246:
        -:  247:
function _ZN7AVLTreeIi14SoldierCompareIiEE7BalanceEPNS2_4NodeE called 0 returned 0% blocks executed 0%
    #####:  248:    Node *Balance(Node *balancing) {
    #####:  249:        Node *returned = balancing;
        -:  250:
    #####:  251:        if (BalanceFactor(balancing) == -2) { //Делаем левый поворот при необходимости
    %%%%%:  251-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  252:            if (BalanceFactor(balancing->right) == 1) { //Делаем большой левый поворот при необходимости
    %%%%%:  252-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  253:                Node *tmp = balancing->right;
    #####:  254:                balancing->right = balancing->right->left;          //Перепривязываем ноды
    #####:  255:                RightRotate(tmp);                            //Делаем малый правый поворот
    %%%%%:  255-block  0
call    0 never executed
        -:  256:            }
    #####:  257:            returned = balancing->right;                             //Меняем возвращаемую ноду
    #####:  258:            LeftRotate(balancing);                                //Делаем левый поворот
    %%%%%:  258-block  0
call    0 never executed
        -:  259:
    #####:  260:        } else if (BalanceFactor(balancing) == 2) {            //Симметричные действия
    %%%%%:  260-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  261:            if (BalanceFactor(balancing->left) == -1) {
    %%%%%:  261-block  0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  262:                Node *tmp = balancing->left;
    #####:  263:                balancing->left = balancing->left->right;
    #####:  264:                LeftRotate(tmp);
    %%%%%:  264-block  0
call    0 never executed
        -:  265:            }
    #####:  266:            returned = balancing->left;
    #####:  267:            RightRotate(balancing);
    %%%%%:  267-block  0
call    0 never executed
        -:  268:        }
        -:  269:
    #####:  270:        returned->weight = Weight(returned->left) + Weight(returned->right) + 1;//Обновляем вес
    %%%%%:  270-block  0
call    0 never executed
call    1 never executed
        -:  271:
    #####:  272:        returned->height = max(Height(returned->left), Height(returned->right)) + 1;//Обновляем высоту
call    0 never executed
call    1 never executed
call    2 never executed
        -:  273:
    #####:  274:        return returned;
        -:  275:    }
        -:  276:
function _ZN7AVLTreeIi14SoldierCompareIiEE10LeftRotateEPNS2_4NodeE called 0 returned 0% blocks executed 0%
    #####:  277:    void LeftRotate(Node *rotated) {
    #####:  278:        Node *tmp = rotated->right;
    #####:  279:        rotated->right = tmp->left;                             //Перепривязываем ноды
    #####:  280:        tmp->left = rotated;
        -:  281:
    #####:  282:        rotated->weight = Weight(rotated->left) + Weight(rotated->right) + 1; //Обновляем веса
    %%%%%:  282-block  0
call    0 never executed
call    1 never executed
    #####:  283:        tmp->weight = Weight(tmp->left) + Weight(tmp->right) + 1;
call    0 never executed
call    1 never executed
        -:  284:
    #####:  285:        rotated->height = max(Height(rotated->left), Height(rotated->right)) + 1; //Обновляем высоты
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  286:        tmp->height = max(Height(tmp->left), Height(tmp->right)) + 1;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  287:    }
        -:  288:
function _ZN7AVLTreeIi14SoldierCompareIiEE11RightRotateEPNS2_4NodeE called 0 returned 0% blocks executed 0%
    #####:  289:    void RightRotate(Node *rotated) {
        -:  290:
    #####:  291:        Node *tmp = rotated->left;
    #####:  292:        rotated->left = tmp->right;
    #####:  293:        tmp->right = rotated;
        -:  294:
    #####:  295:        rotated->weight = Weight(rotated->left) + Weight(rotated->right) + 1;
    %%%%%:  295-block  0
call    0 never executed
call    1 never executed
    #####:  296:        tmp->weight = Weight(tmp->left) + Weight(tmp->right) + 1;
call    0 never executed
call    1 never executed
        -:  297:
    #####:  298:        rotated->height = max(Height(rotated->left), Height(rotated->right)) + 1;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  299:        tmp->height = max(Height(tmp->left), Height(tmp->right)) + 1;
call    0 never executed
call    1 never executed
call    2 never executed
    #####:  300:    }
        -:  301:
        -:  302:};
        -:  303:
function main called 1 returned 100% blocks executed 83%
        1:  304:int main() {
        -:  305:    int n;
        1:  306:    cin >> n;
        1:  306-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  307:    AVLTree<int, SoldierCompare<int>> tree;
        1:  307-block  0
call    0 returned 1
    $$$$$:  307-block  1
call    1 never executed
        -:  308:
        6:  309:    for (int i = 0; i < n; ++i) {
        6:  309-block  0
branch  0 taken 5 (fallthrough)
branch  1 taken 1
        5:  309-block  1
        -:  310:        int command, value;
        5:  311:        cin >> command >> value;
        5:  311-block  0
call    0 returned 5
branch  1 taken 5 (fallthrough)
branch  2 taken 0 (throw)
        5:  311-block  1
call    3 returned 5
branch  4 taken 5 (fallthrough)
branch  5 taken 0 (throw)
        -:  312:
        5:  313:        if (command == 1) {       //Если добавляем солдата, то выводим его позицию и
        5:  313-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        4:  314:            cout << tree.Position(value) << endl;                      //добавляем его
        4:  314-block  0
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0 (throw)
        4:  314-block  1
call    3 returned 4
branch  4 taken 4 (fallthrough)
branch  5 taken 0 (throw)
        4:  314-block  2
call    6 returned 4
branch  7 taken 4 (fallthrough)
branch  8 taken 0 (throw)
        4:  315:            tree.Add(value);
        4:  315-block  0
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0 (throw)
        -:  316:        } else {
        1:  317:            tree.Delete(tree.KStatistics(value).second); //Если солдат уходит из строя, то запрашиваем к-статистику
        1:  317-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  317-block  1
call    3 returned 1
branch  4 taken 1 (fallthrough)
branch  5 taken 0 (throw)
        1:  317-block  2
    $$$$$:  317-block  3
        -:  318:        }                                             //у дерева и удаляем солдата на данной позиции
        -:  319:    }
        -:  320:
        1:  321:    return 0;
        1:  321-block  0
call    0 returned 1
        -:  322:}
        -:  323:
        -:  324:template<class T, class Cmp>
function _ZN7AVLTreeIi14SoldierCompareIiEE8PositionERKi called 4 returned 100% blocks executed 100%
        4:  325:int AVLTree<T, Cmp>::Position(const T &key) {
        4:  326:    return PositionTrail(root, key);
        4:  326-block  0
call    0 returned 4
        -:  327:}
        -:  328:
        -:  329:template<class T, class Cmp>
function _ZN7AVLTreeIi14SoldierCompareIiEE11KStatisticsEi called 1 returned 100% blocks executed 46%
        1:  330:pair<bool, T> AVLTree<T, Cmp>::KStatistics(int index) {
        -:  331:
        1:  332:    if (index >= size) {
        1:  332-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  333:        return make_pair(false, 0);
        1:  333-block  0
call    0 returned 1
branch  1 taken 1 (fallthrough)
branch  2 taken 0 (throw)
        1:  333-block  1
        1:  333-block  2
    $$$$$:  333-block  3
    $$$$$:  333-block  4
call    3 never executed
        -:  334:    }
        -:  335:
    #####:  336:    return make_pair(true, StatisticsTrail(root, index));
    %%%%%:  336-block  0
call    0 never executed
call    1 never executed
branch  2 never executed
branch  3 never executed
    %%%%%:  336-block  1
    %%%%%:  336-block  2
    $$$$$:  336-block  3
        -:  337:}
        -:  338:
        -:  339:
        -:  340:
        -:  341:
        -:  342:
        -:  343:
        -:  344:
        -:  345:
